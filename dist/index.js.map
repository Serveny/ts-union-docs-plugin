{"version":3,"file":"index.js","sources":["../src/info.ts","../src/docs.ts","../src/completion.ts","../src/plugin.ts","../src/index.ts"],"sourcesContent":["import type * as TS from 'typescript/lib/tsserverlibrary';\n\nexport enum SupportedType {\n\tParamter,\n\tVariable,\n}\n\n// This class holds every type information the plugin needs\nexport class UnionInfo {\n\tconstructor(\n\t\tpublic type: SupportedType,\n\t\tpublic name: string,\n\t\tpublic initNode: CalledNode,\n\t\t// Can be multiple nodes because different union types can have same values\n\t\tpublic entries: CalledNode[],\n\t\tpublic value?: string,\n\t\tpublic docComment?: string[]\n\t) {}\n}\n\nexport interface CalledNode extends TS.Node {\n\tid?: number;\n\tcallParent?: CalledNode; // The node that references to it\n\toriginal?: TS.Node; // For resolved nodes\n\tisRegexPattern?: boolean; // For template syntax like ${number}\n\tcodeText?: string;\n}\n\nexport class TypeInfoFactory {\n\tprivate checker!: TS.TypeChecker;\n\n\tconstructor(private ts: typeof TS, private ls: TS.LanguageService) {}\n\n\tgetTypeInfo(fileName: string, position: number): UnionInfo[] | null {\n\t\tconst node = this.getInitNode(fileName, position);\n\t\tif (!node) return null;\n\n\t\tconst symbol = this.checker.getSymbolAtLocation(node);\n\t\tif (!symbol) return null;\n\n\t\t// Find union type parameter info for function call\n\t\tconst callExpression = this.getCallExpression(node);\n\t\tif (callExpression) return this.getUnionParamtersInfo(callExpression);\n\n\t\tconst variableInfo = this.getUnionVariableInfo(symbol);\n\t\tif (variableInfo) return [variableInfo];\n\n\t\treturn null;\n\t}\n\n\tgetContextualTypeInfo(fileName: string, position: number): UnionInfo | null {\n\t\tconst node = this.getInitNode(fileName, position);\n\t\tif (!node || !this.ts.isExpression(node)) return null;\n\n\t\tconst contextualType = this.checker.getContextualType(node);\n\t\tif (!contextualType) return null;\n\n\t\tconst typeNode = this.resolveTypeNode(node, contextualType);\n\t\tif (!typeNode) return null;\n\n\t\tconst unionMemberNodes = this.collectUnionMemberNodes(typeNode);\n\t\tconst filteredNodes = this.filterRegexMembers(\n\t\t\tunionMemberNodes,\n\t\t\tcontextualType\n\t\t);\n\n\t\treturn new UnionInfo(\n\t\t\tSupportedType.Variable,\n\t\t\t'completion',\n\t\t\tnode,\n\t\t\tfilteredNodes,\n\t\t\tundefined\n\t\t);\n\t}\n\n\tprivate resolveTypeNode(\n\t\tnode: TS.Expression,\n\t\tcontextualType: TS.Type\n\t): TS.TypeNode | null {\n\t\tconst aliasNode = this.getTypeNodeFromAlias(contextualType);\n\t\tif (aliasNode) return aliasNode;\n\n\t\tconst paramNode = this.getTypeNodeFromParameter(node);\n\t\tif (paramNode) return paramNode;\n\n\t\treturn this.getTypeNodeFromInitializer(node);\n\t}\n\n\tprivate getTypeNodeFromAlias(type: TS.Type): TS.TypeNode | null {\n\t\tconst decl = type.aliasSymbol?.getDeclarations()?.[0];\n\t\tif (decl && this.ts.isTypeAliasDeclaration(decl)) {\n\t\t\treturn decl.type;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate getTypeNodeFromParameter(node: TS.Expression): TS.TypeNode | null {\n\t\tconst callLike = this.findCallLikeExpression(node);\n\t\tif (!callLike) return null;\n\n\t\tconst signature = this.checker.getResolvedSignature(callLike);\n\t\tconst argIndex = callLike.arguments?.indexOf(node as any) ?? 0;\n\t\tconst paramSymbol = signature?.getParameters()[argIndex];\n\t\tconst paramDecl = paramSymbol?.getDeclarations()?.[0];\n\n\t\treturn paramDecl && this.ts.isParameter(paramDecl) && paramDecl.type\n\t\t\t? paramDecl.type\n\t\t\t: null;\n\t}\n\n\tprivate getTypeNodeFromInitializer(node: TS.Expression): TS.TypeNode | null {\n\t\tconst parent = node.parent;\n\t\tif (!parent) return null;\n\n\t\tif (\n\t\t\tthis.ts.isVariableDeclaration(parent) ||\n\t\t\tthis.ts.isPropertyDeclaration(parent)\n\t\t) {\n\t\t\treturn parent.initializer === node ? parent.type ?? null : null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate filterRegexMembers(\n\t\tmembers: CalledNode[],\n\t\tcontextualType: TS.Type\n\t): CalledNode[] {\n\t\treturn members.filter((memberNode) => {\n\t\t\tif (memberNode.isRegexPattern !== true) return false;\n\n\t\t\tconst original =\n\t\t\t\tmemberNode.callParent ?? memberNode.original ?? memberNode;\n\n\t\t\tif (this.ts.isTemplateLiteralTypeNode(memberNode)) {\n\t\t\t\treturn (contextualType.getFlags() & this.ts.TypeFlags.StringLike) !== 0;\n\t\t\t}\n\n\t\t\tconst memberType = this.checker.getTypeAtLocation(original);\n\t\t\tconst isMatch = this.checker.isTypeAssignableTo(\n\t\t\t\tmemberType,\n\t\t\t\tcontextualType\n\t\t\t);\n\t\t\treturn isMatch;\n\t\t});\n\t}\n\n\tprivate findCallLikeExpression(\n\t\tnode: TS.Node\n\t): TS.CallExpression | TS.NewExpression | undefined {\n\t\tlet current = node.parent;\n\t\twhile (current && !this.ts.isSourceFile(current)) {\n\t\t\tif (this.ts.isCallExpression(current) || this.ts.isNewExpression(current))\n\t\t\t\treturn current;\n\t\t\tcurrent = current.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate getUnionInfo(\n\t\tparamSymbol: TS.Symbol,\n\t\targ: TS.Expression\n\t): UnionInfo | null {\n\t\tconst decl = paramSymbol.valueDeclaration;\n\t\tif (!decl || !this.ts.isParameter(decl) || !decl.type) return null;\n\n\t\tconst unionMemberNodes = this.collectUnionMemberNodes(decl.type);\n\t\tif (unionMemberNodes.length === 0) return null;\n\n\t\tconst value = this.getValue(arg);\n\t\tconst valueNodes = unionMemberNodes.filter((entry) => this.cmp(arg, entry));\n\n\t\treturn new UnionInfo(\n\t\t\tSupportedType.Paramter,\n\t\t\tparamSymbol.name,\n\t\t\tdecl.type,\n\t\t\tvalueNodes,\n\t\t\tvalue\n\t\t);\n\t}\n\n\tprivate getUnionVariableInfo(symbol: TS.Symbol): UnionInfo | null {\n\t\tconst decl = symbol.valueDeclaration;\n\t\tif (\n\t\t\t!decl ||\n\t\t\t!(\n\t\t\t\tthis.ts.isVariableDeclaration(decl) ||\n\t\t\t\tthis.ts.isPropertyDeclaration(decl)\n\t\t\t)\n\t\t)\n\t\t\treturn null;\n\t\tif (!decl.type || !decl.initializer) return null;\n\n\t\tconst unionMemberNodes = this.collectUnionMemberNodes(decl.type);\n\t\tif (unionMemberNodes.length === 0) return null;\n\n\t\tconst value = this.getValue(decl.initializer);\n\t\tconst valueNodes = unionMemberNodes.filter((entry) =>\n\t\t\tthis.cmp(decl.initializer as TS.Expression, entry)\n\t\t);\n\n\t\treturn new UnionInfo(\n\t\t\tSupportedType.Variable,\n\t\t\tsymbol.name,\n\t\t\tdecl.type,\n\t\t\tvalueNodes,\n\t\t\tvalue\n\t\t);\n\t}\n\n\tprivate getInitNode(fileName: string, position: number) {\n\t\tconst program = this.ls.getProgram();\n\t\tif (!program) return null;\n\n\t\tthis.checker = program.getTypeChecker();\n\t\tif (!this.checker) return null;\n\n\t\tconst source = program.getSourceFile(fileName);\n\t\tif (!source) return null;\n\n\t\tconst node = this.findNodeAtPos(source, position);\n\t\tif (!node) return null;\n\n\t\treturn node;\n\t}\n\n\tprivate findNodeAtPos(srcFile: TS.SourceFile, pos: number): TS.Node | null {\n\t\tconst find = (node: TS.Node): TS.Node | null =>\n\t\t\tpos >= node.getStart() && pos < node.getEnd()\n\t\t\t\t? this.ts.forEachChild(node, find) || node\n\t\t\t\t: null;\n\t\treturn find(srcFile);\n\t}\n\n\tprivate getCallExpression(node: TS.Node): TS.CallExpression | null {\n\t\tif (this.ts.isCallExpression(node)) return node;\n\t\twhile (node && !this.ts.isCallExpression(node)) node = node.parent;\n\t\treturn node;\n\t}\n\n\tprivate getUnionParamtersInfo(callExpr: TS.CallExpression): UnionInfo[] {\n\t\tconst paramTypes: UnionInfo[] = [];\n\t\tconst signature = this.checker.getResolvedSignature(callExpr);\n\t\tif (!signature) return paramTypes;\n\n\t\tconst args = callExpr.arguments;\n\t\tconst params = signature.getParameters();\n\t\tfor (let i = 0; i < params.length; i++) {\n\t\t\tconst paramInfo = this.getUnionInfo(params[i], args[i]);\n\t\t\tif (paramInfo) paramTypes.push(paramInfo);\n\t\t}\n\n\t\treturn paramTypes;\n\t}\n\n\tprivate getValue(expr: TS.Expression): string {\n\t\treturn this.ts.isLiteralExpression(expr) ? expr.text : expr.getText();\n\t}\n\n\tprivate collectUnionMemberNodes(\n\t\tnode: TS.Node,\n\t\tcallParent?: TS.Node\n\t): CalledNode[] {\n\t\tconst ts = this.ts;\n\t\t(node as any).codeText = getNodeText(node);\n\n\t\tif (\n\t\t\tts.isUnionTypeNode(node) || // e.g. string | number\n\t\t\tts.isIntersectionTypeNode(node) || // e.g. Class1 & Class2\n\t\t\tts.isHeritageClause(node) // e.g. Class1 extends BaseClass implements Interface1\n\t\t) {\n\t\t\treturn node.types.flatMap((tn) =>\n\t\t\t\tthis.collectUnionMemberNodes(tn, callParent)\n\t\t\t);\n\t\t}\n\n\t\t// e.g. T extends U ? string : number\n\t\tif (ts.isConditionalTypeNode(node))\n\t\t\treturn this.collectConditionalTypeNode(node);\n\n\t\t// e.g. Object1[\"propName\"]\n\t\tif (ts.isIndexedAccessTypeNode(node))\n\t\t\treturn this.collectIndexedAccessTypeNode(node);\n\n\t\t// e.g. { prop1: string; prop2: number }\n\t\tif (ts.isTypeLiteralNode(node)) return this.collectTypeLiteralNode(node);\n\n\t\t// e.g. { [K in keyof T]: T[K] }\n\t\tif (ts.isMappedTypeNode(node)) return this.collectMappedTypeNode(node);\n\n\t\t// e.g. Promise<string>\n\t\tif (ts.isTypeReferenceNode(node))\n\t\t\treturn this.collectTypeReferenceNode(node);\n\n\t\t// e.g. keyof Class1\n\t\tif (\n\t\t\tts.isTypeOperatorNode(node) &&\n\t\t\tnode.operator === ts.SyntaxKind.KeyOfKeyword\n\t\t)\n\t\t\treturn this.collectKeyOfKeywordTypeOperatorNode(node, callParent);\n\n\t\t// e.g. (string | number)[]\n\t\tif (ts.isParenthesizedTypeNode(node))\n\t\t\treturn this.collectUnionMemberNodes(node.type, node);\n\n\t\t// e.g. string[]\n\t\tif (ts.isArrayTypeNode(node))\n\t\t\treturn this.collectUnionMemberNodes(node.elementType, node);\n\n\t\t// e.g. [string, number, boolean]\n\t\tif (ts.isTupleTypeNode(node)) return this.collectTupleTypeNode(node);\n\n\t\t// e.g. typeof var1\n\t\tif (ts.isTypeQueryNode(node)) return this.collectTypeQueryNode(node);\n\n\t\t// e.g. `text-${number}`\n\t\tif (ts.isTemplateLiteralTypeNode(node))\n\t\t\treturn this.buildTemplateLiteralNode(node);\n\n\t\t// This is the end of the journey\n\t\tif (\n\t\t\tts.isLiteralTypeNode(node) || // e.g. \"text\", 42, true\n\t\t\tts.isTypeNode(node) // e.g. string, number, boolean\n\t\t) {\n\t\t\treturn [calledNode(node, callParent)];\n\t\t}\n\n\t\tconsole.warn('Unknown node type: ', node);\n\t\treturn [];\n\t}\n\n\tprivate collectConditionalTypeNode(\n\t\tnode: TS.ConditionalTypeNode\n\t): CalledNode[] {\n\t\treturn [\n\t\t\t...this.collectUnionMemberNodes(node.checkType, node),\n\t\t\t...this.collectUnionMemberNodes(node.extendsType, node),\n\t\t\t...this.collectUnionMemberNodes(node.trueType, node),\n\t\t\t...this.collectUnionMemberNodes(node.falseType, node),\n\t\t];\n\t}\n\n\tprivate collectIndexedAccessTypeNode(\n\t\tnode: TS.IndexedAccessTypeNode\n\t): CalledNode[] {\n\t\treturn [\n\t\t\t...this.collectUnionMemberNodes(node.objectType, node),\n\t\t\t...this.collectUnionMemberNodes(node.indexType, node),\n\t\t];\n\t}\n\n\tprivate collectTypeLiteralNode(node: TS.TypeLiteralNode): CalledNode[] {\n\t\treturn node.members.flatMap((m) =>\n\t\t\t(m as any).type ? this.collectUnionMemberNodes((m as any).type, node) : []\n\t\t);\n\t}\n\n\tprivate collectMappedTypeNode(node: TS.MappedTypeNode): CalledNode[] {\n\t\tconst results: TS.Node[] = [];\n\t\tif (node.typeParameter.constraint)\n\t\t\tresults.push(\n\t\t\t\t...this.collectUnionMemberNodes(node.typeParameter.constraint, node)\n\t\t\t);\n\t\tif (node.type)\n\t\t\tresults.push(...this.collectUnionMemberNodes(node.type, node));\n\t\treturn results;\n\t}\n\n\tprivate collectTypeReferenceNode(node: TS.TypeReferenceNode): CalledNode[] {\n\t\tconst checker = this.checker,\n\t\t\tts = this.ts,\n\t\t\tsymbol = checker.getSymbolAtLocation(node.typeName);\n\t\tif (!symbol) return [];\n\n\t\tconst aliasedSymbol =\n\t\t\tsymbol.flags & ts.SymbolFlags.Alias\n\t\t\t\t? checker.getAliasedSymbol(symbol)\n\t\t\t\t: symbol;\n\n\t\tconst decl = aliasedSymbol.declarations?.[0];\n\t\tif (!decl) return [];\n\t\tconst tn = ts.isTypeParameterDeclaration(decl)\n\t\t\t? decl.constraint ?? null\n\t\t\t: ts.isTypeAliasDeclaration(decl)\n\t\t\t? decl.type\n\t\t\t: null;\n\t\tif (!tn) return [];\n\t\treturn this.collectUnionMemberNodes(tn, node);\n\t}\n\n\tprivate collectKeyOfKeywordTypeOperatorNode(\n\t\tnode: TS.TypeOperatorNode,\n\t\tcallParent?: TS.Node\n\t): CalledNode[] {\n\t\tconst ts = this.ts,\n\t\t\tchecker = this.checker,\n\t\t\ttype = checker.getTypeAtLocation(node.type);\n\t\treturn type.getProperties().map((p) => {\n\t\t\tconst decl = p.getDeclarations()?.[0];\n\t\t\tconst litNode = ts.factory.createLiteralTypeNode(\n\t\t\t\tts.factory.createStringLiteral(p.getName())\n\t\t\t);\n\t\t\treturn calledNode(litNode, callParent, decl);\n\t\t});\n\t}\n\n\tprivate collectTupleTypeNode(node: TS.TupleTypeNode): CalledNode[] {\n\t\treturn node.elements.flatMap((el) =>\n\t\t\tthis.collectUnionMemberNodes(el, node)\n\t\t);\n\t}\n\n\tprivate collectTypeQueryNode(node: TS.TypeQueryNode): CalledNode[] {\n\t\tconst symbol = this.checker.getSymbolAtLocation(node.exprName);\n\t\tif (symbol) {\n\t\t\tconst decls = symbol.getDeclarations() ?? [];\n\t\t\treturn decls.flatMap((d) =>\n\t\t\t\tthis.collectUnionMemberNodes(d as TS.Node, node)\n\t\t\t);\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate createLiteralNode<T extends TS.Node>(\n\t\tnode: T,\n\t\ttext: string,\n\t\tcallParent?: TS.Node,\n\t\tisRegexPattern?: boolean,\n\t\toriginalOverride?: TS.Node\n\t): CalledNode & TS.LiteralLikeNode {\n\t\tconst litNode = this.ts.factory.createStringLiteral(text);\n\t\tconst original = originalOverride ?? (node as any).original ?? node;\n\t\t(litNode as any).id = (original as any).id ?? (node as any).id;\n\t\treturn calledNode(litNode, callParent, original, isRegexPattern);\n\t}\n\n\t// Creates new literal nodes with every possible content\n\tprivate buildTemplateLiteralNode(\n\t\tnode: TS.TemplateLiteralTypeNode\n\t): CalledNode[] {\n\t\tconst headText = node.head.text,\n\t\t\tts = this.ts;\n\t\tconst nodes: (CalledNode & TS.LiteralLikeNode)[][] = [];\n\n\t\tfor (const span of node.templateSpans) {\n\t\t\tconst spanNodes: (CalledNode & TS.LiteralLikeNode)[] = [];\n\t\t\tconst innerTypeNodes = this.collectUnionMemberNodes(span.type, node);\n\n\t\t\tfor (const tn of innerTypeNodes) {\n\t\t\t\tif (tn.isRegexPattern != null)\n\t\t\t\t\tspanNodes.push(tn as CalledNode & TS.LiteralLikeNode);\n\t\t\t\t// Literal: \"foo\" -> \"foo\"\n\t\t\t\telse if (\n\t\t\t\t\tts.isLiteralTypeNode(tn) &&\n\t\t\t\t\t(this.ts.isStringLiteral(tn.literal) ||\n\t\t\t\t\t\tthis.ts.isNumericLiteral(tn.literal))\n\t\t\t\t)\n\t\t\t\t\tspanNodes.push(\n\t\t\t\t\t\tthis.createLiteralNode(\n\t\t\t\t\t\t\ttn,\n\t\t\t\t\t\t\ttn.literal.text + span.literal.text,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t// number\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.NumberKeyword)\n\t\t\t\t\tspanNodes.push(\n\t\t\t\t\t\tthis.createLiteralNode(\n\t\t\t\t\t\t\ttn,\n\t\t\t\t\t\t\t'\\\\d+(\\\\.\\\\d+)?' + span.literal.text,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t// boolean\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.BooleanKeyword)\n\t\t\t\t\tspanNodes.push(\n\t\t\t\t\t\tthis.createLiteralNode(\n\t\t\t\t\t\t\ttn,\n\t\t\t\t\t\t\t'(true|false)' + span.literal.text,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t// string (caution: greedy)\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.StringKeyword)\n\t\t\t\t\tspanNodes.push(\n\t\t\t\t\t\tthis.createLiteralNode(tn, '\\\\.\\\\*' + span.literal.text, node, true)\n\t\t\t\t\t);\n\t\t\t\t// Fallback for unknown types\n\t\t\t\telse console.warn('Unknown type of template: ', tn);\n\t\t\t}\n\n\t\t\tnodes.push(spanNodes);\n\t\t}\n\n\t\tconst catProd = cartesianProduct(nodes).flatMap((compNodes) => {\n\t\t\tconst isRegex = compNodes.some((n) => n.isRegexPattern === true);\n\t\t\tconst txt = (n: CalledNode & TS.LiteralLikeNode) =>\n\t\t\t\tisRegex && n.isRegexPattern === false ? escapeRegExp(n.text) : n.text;\n\t\t\tconst head = isRegex ? escapeRegExp(headText) : headText;\n\t\t\tconst fullText = head + compNodes.map(txt).join('');\n\t\t\treturn compNodes.map((cn) => {\n\t\t\t\tconst originalOverride =\n\t\t\t\t\tcn.isRegexPattern === true &&\n\t\t\t\t\tcn.callParent != null &&\n\t\t\t\t\tcn.callParent !== node &&\n\t\t\t\t\tts.isTemplateLiteralTypeNode(cn.callParent)\n\t\t\t\t\t\t? cn.callParent\n\t\t\t\t\t\t: undefined;\n\t\t\t\treturn this.createLiteralNode(\n\t\t\t\t\tcn,\n\t\t\t\t\tfullText,\n\t\t\t\t\tnode,\n\t\t\t\t\tisRegex,\n\t\t\t\t\toriginalOverride\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\treturn catProd;\n\t}\n\n\tprivate cmp(expr: TS.Expression, node: CalledNode): boolean {\n\t\t// check for generated regex pattern\n\t\tif (isRegexNode(node) && this.ts.isStringLiteral(expr)) {\n\t\t\t// Surround with ^...$, so the whole string must match\n\t\t\tconst pattern = new RegExp(`^${node.text}$`);\n\t\t\treturn pattern.test(expr.text);\n\t\t}\n\t\tif (node.isRegexPattern === false) return this.cmpLit(expr, node as any);\n\t\tif (!this.ts.isLiteralTypeNode(node)) return false;\n\t\treturn this.cmpLit(expr, node.literal);\n\t}\n\n\tprivate cmpLit(\n\t\texpr: TS.Expression,\n\t\ttypeLiteral:\n\t\t\t| TS.LiteralExpression\n\t\t\t| TS.NullLiteral\n\t\t\t| TS.BooleanLiteral\n\t\t\t| TS.PrefixUnaryExpression\n\t) {\n\t\tconst ts = this.ts;\n\t\t// string literals (i.e. \"hello\" and type T = \"hello\")\n\t\tif (ts.isStringLiteral(expr) && ts.isStringLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// numeric literals (i.e. 42 and type T = 42)\n\t\tif (ts.isNumericLiteral(expr) && ts.isNumericLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// BigInt literals (i.e. 100n and type T = 100n)\n\t\tif (ts.isBigIntLiteral(expr) && ts.isBigIntLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// booleans (compare kind of nodes)\n\t\tif (\n\t\t\t(expr.kind === ts.SyntaxKind.TrueKeyword &&\n\t\t\t\ttypeLiteral.kind === ts.SyntaxKind.TrueKeyword) ||\n\t\t\t(expr.kind === ts.SyntaxKind.FalseKeyword &&\n\t\t\t\ttypeLiteral.kind === ts.SyntaxKind.FalseKeyword)\n\t\t)\n\t\t\treturn true;\n\n\t\t// TODO: objects\n\n\t\t// null\n\t\tif (\n\t\t\texpr.kind === ts.SyntaxKind.NullKeyword &&\n\t\t\ttypeLiteral.kind === ts.SyntaxKind.NullKeyword\n\t\t)\n\t\t\treturn true;\n\n\t\t// undefined\n\t\tif (\n\t\t\texpr.kind === ts.SyntaxKind.UndefinedKeyword &&\n\t\t\ttypeLiteral.kind === ts.SyntaxKind.UndefinedKeyword\n\t\t)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n}\n\nfunction calledNode<T extends TS.Node>(\n\tnode: T,\n\tcallParent?: TS.Node,\n\toriginal?: TS.Node,\n\tisRegex?: boolean\n): CalledNode & T {\n\tconst cNode = node as CalledNode;\n\tcNode.callParent = callParent as any;\n\tcNode.original = original;\n\tcNode.isRegexPattern = isRegex;\n\treturn cNode as any;\n}\n\nfunction getNodeText(node: TS.Node) {\n\tconst text = node.getSourceFile()?.text;\n\tif (!text) return '<No Source>';\n\treturn text.substring(node.getStart(), node.getEnd());\n}\n\nexport function isRegexNode(\n\tnode: CalledNode\n): node is TS.StringLiteral & CalledNode {\n\treturn node.isRegexPattern === true;\n}\n\nfunction escapeRegExp(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction cartesianProduct<T>(arrays: T[][]): T[][] {\n\treturn arrays.reduce(\n\t\t(acc, curr) => acc.flatMap((d) => curr.map((e) => [...d, e])),\n\t\t[[]] as T[][]\n\t);\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { CalledNode, SupportedType, UnionInfo } from './info';\n\ntype TagIdx = {\n\ttag: TS.JSDocTagInfo;\n\tidx: number;\n};\n\nexport function addExtraQuickInfo(\n\tts: typeof TS,\n\tquickInfo: TS.QuickInfo,\n\ttypesInfo: UnionInfo[]\n) {\n\tif (typesInfo.length === 0) return;\n\ttypesInfo.forEach((p) => addDocComment(ts, p));\n\n\t// if the first type is a param, the others must also be parameters\n\tswitch (typesInfo[0].type) {\n\t\tcase SupportedType.Paramter:\n\t\t\treturn addExtraJDocTagInfo(quickInfo, typesInfo);\n\t\tcase SupportedType.Variable:\n\t\t\treturn addExtraDocumentation(quickInfo, typesInfo);\n\t}\n}\n\nfunction addExtraJDocTagInfo(quickInfo: TS.QuickInfo, typesInfo: UnionInfo[]) {\n\tif (!quickInfo.tags) quickInfo.tags = [];\n\n\tconst tagIdxs: TagIdx[] =\n\t\tquickInfo.tags\n\t\t\t?.map((tag, idx) => ({ tag, idx }))\n\t\t\t.filter((ti) => ti.tag.name === 'param') ?? [];\n\n\t// Create new tag list to prevent tags stacking up over time in quick info\n\tconst newTags = [\n\t\t...(tagIdxs.length > 0\n\t\t\t? quickInfo.tags.filter((_, i) => i < tagIdxs[0].idx)\n\t\t\t: quickInfo.tags),\n\t];\n\n\tfor (const typeInfo of typesInfo) {\n\t\tconst jsDocTag = findJsDocParamTagByName(tagIdxs, typeInfo.name);\n\n\t\t// If type info found, create new quick info tag\n\t\tif ((typeInfo.docComment?.length ?? 0) > 0) {\n\t\t\t// If no js doc comment for param found, fill with default\n\t\t\tconst tag = jsDocTag?.tag ?? defaultParamJSDocTag(typeInfo.name);\n\t\t\tconst newTag = addTagInfo(tag, typeInfo);\n\t\t\tnewTags.push(newTag);\n\t\t}\n\t}\n\n\t// If tags after last param tag left, add them to new tag list\n\tconst lastParamTagIdx =\n\t\ttagIdxs.length === 0 ? 0 : tagIdxs[tagIdxs.length - 1]?.idx ?? 0;\n\tif (quickInfo.tags.length - 1 > lastParamTagIdx)\n\t\tnewTags.push(...quickInfo.tags.filter((_, i) => i > lastParamTagIdx));\n\n\tquickInfo.tags = newTags;\n}\n\nfunction addExtraDocumentation(\n\tquickInfo: TS.QuickInfo,\n\ttypesInfo: UnionInfo[]\n) {\n\tconst newDocs = quickInfo.documentation ? [...quickInfo.documentation] : [];\n\n\tfor (const typeInfo of typesInfo) {\n\t\tnewDocs.push(\n\t\t\tcreateMarkdownDisplayPart(\n\t\t\t\ttypeInfo.docComment\n\t\t\t\t\t?.map((line, i) => (i > 0 ? (line = '> ' + line) : line))\n\t\t\t\t\t.join('\\n') ?? ''\n\t\t\t)\n\t\t);\n\t}\n\tquickInfo.documentation = newDocs;\n}\n\nfunction findJsDocParamTagByName(tags: TagIdx[], name: string): TagIdx | null {\n\tconst foundTag = tags.find(({ tag }) =>\n\t\ttag.text?.some(\n\t\t\t(textPart) =>\n\t\t\t\ttextPart.kind === 'parameterName' &&\n\t\t\t\ttextPart.text.toLowerCase() === name.toLowerCase()\n\t\t)\n\t);\n\treturn foundTag ?? null;\n}\n\nfunction defaultParamJSDocTag(name: string): TS.JSDocTagInfo {\n\treturn {\n\t\tname: 'param',\n\t\ttext: [\n\t\t\t{\n\t\t\t\tkind: 'keyword',\n\t\t\t\ttext: name,\n\t\t\t},\n\t\t],\n\t};\n}\n\nfunction createMarkdownDisplayPart(mdText: string): TS.SymbolDisplayPart {\n\treturn {\n\t\ttext: mdText,\n\t\tkind: 'markdown',\n\t} as TS.SymbolDisplayPart;\n}\n\nfunction addTagInfo(\n\toldTag: TS.JSDocTagInfo,\n\ttypeInfo: UnionInfo | undefined\n): TS.JSDocTagInfo {\n\tif (!typeInfo?.docComment) return oldTag;\n\tconst newTag: TS.JSDocTagInfo = JSON.parse(JSON.stringify(oldTag));\n\tif (!newTag.text) newTag.text = [];\n\tnewTag.text.push(\n\t\tcreateMarkdownDisplayPart(\n\t\t\ttypeInfo.docComment\n\t\t\t\t?.map((line, i) => (i > 0 ? (line = '> ' + line) : line))\n\t\t\t\t.join('\\n')\n\t\t)\n\t);\n\treturn newTag;\n}\n\nfunction addDocComment(ts: typeof TS, param: UnionInfo) {\n\tconst visitedNodes = new Set();\n\tconst comments: string[][] = [];\n\n\tfunction add(node: CalledNode): boolean {\n\t\tconst id = node.id;\n\t\tif (visitedNodes.has(id)) return false;\n\t\tvisitedNodes.add(id);\n\t\tcomments.push(extractJSDocsFromNode(ts, node));\n\t\treturn true;\n\t}\n\n\t// Read out all comments\n\tfor (const entryNode of param.entries.reverse()) {\n\t\tadd(entryNode);\n\n\t\tlet parent = entryNode.callParent;\n\t\twhile (parent != null) {\n\t\t\tadd(parent);\n\t\t\tparent = parent.callParent;\n\t\t}\n\t}\n\n\t// Add the comments in order parent -> ... -> child\n\tconst lines = comments.reverse().flat();\n\tif (!param.docComment) param.docComment = lines;\n\telse param.docComment.push(...lines);\n}\n\nfunction extractJSDocsFromNode(ts: typeof TS, node: CalledNode): string[] {\n\t// If the node was resolved, get the original node\n\tnode = node.original ?? node;\n\tconst sourceFile = node.getSourceFile();\n\tif (!sourceFile) return [];\n\tconst sourceText = sourceFile.getFullText();\n\tconst start = node.getStart();\n\tconst comment = getLeadingComment(ts, sourceText, start);\n\n\treturn comment\n\t\t? prepareJSDocText(sourceText.substring(comment.pos, comment.end))\n\t\t: [];\n}\n\nfunction getLeadingComment(\n\tts: typeof TS,\n\ttext: string,\n\tpos: number\n): TS.CommentRange | undefined {\n\tconst comments = ts.getLeadingCommentRanges(text, pos) ?? [];\n\n\t// jsdoc comment (has to start with /**)\n\tif (comments.length > 0 && text[comments[0].pos + 2] === '*')\n\t\treturn comments[comments.length - 1];\n\n\ttext = text.substring(0, pos);\n\tconst commentStart = text.lastIndexOf('/**');\n\tif (commentStart === -1) return;\n\n\tconst commentEnd = text.lastIndexOf('*/');\n\tif (commentEnd === -1) return;\n\n\t// only spaces, tabs or linebreaks allowed between comment and node\n\tconst textBetween = text.substring(commentEnd + 2, pos);\n\tif (/[^ \\t|\\n]/.test(textBetween)) return;\n\n\treturn {\n\t\tpos: commentStart + 3,\n\t\tend: commentEnd,\n\t\tkind: ts.SyntaxKind.MultiLineCommentTrivia,\n\t};\n}\n\nfunction prepareJSDocText(rawComment: string): string[] {\n\treturn (\n\t\trawComment\n\t\t\t.replace('/**', '')\n\t\t\t.replace('*/', '')\n\t\t\t.split('\\n')\n\t\t\t// remove whitespace and the leading * in every line\n\t\t\t.map((line) => line.trim().replace(/^\\* ?/, ''))\n\t\t\t// make @tags cursive again\n\t\t\t.map((line) => line.replace(/@(\\w+)/g, (_, tag) => `\\n> _@${tag}_`))\n\t);\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { isRegexNode, UnionInfo } from './info';\n\nexport function addTemplateCompletions(\n\tts: typeof TS,\n\tcompletion: TS.CompletionInfo,\n\tunionInfo: UnionInfo\n) {\n\tconst entries = createTemplateCompletions(ts, unionInfo);\n\tif (entries.length === 0) return;\n\n\tcompletion.entries.push(...entries);\n}\n\nfunction createTemplateCompletions(\n\tts: typeof TS,\n\tunionInfo: UnionInfo\n): TS.CompletionEntry[] {\n\tconst visitedNodes = new Set();\n\n\tconst entries: TS.CompletionEntry[] = [];\n\tconst templateNodes = unionInfo.entries.filter((n) => isRegexNode(n));\n\tif (templateNodes.length === 0) return entries;\n\tconst replacementSpan = getNodeTextSpan(unionInfo.initNode);\n\n\tfor (const tn of templateNodes) {\n\t\tconst snippet = regexToSnippet(tn.text);\n\t\tif (visitedNodes.has(snippet)) continue;\n\t\tvisitedNodes.add(snippet);\n\n\t\tconst name = replaceSnippetDefaults(snippet);\n\t\tentries.push({\n\t\t\tname: name,\n\t\t\tkind: ts.ScriptElementKind.string,\n\t\t\tsortText: name,\n\t\t\tinsertText: snippet,\n\t\t\tisSnippet: true,\n\t\t\treplacementSpan,\n\t\t});\n\t}\n\n\treturn entries;\n}\n\nfunction regexToSnippet(snippet: string): string {\n\tlet i = 1;\n\n\treturn snippet\n\t\t.replace(/\\\\d\\+\\(\\\\\\.\\\\d\\+\\)\\?/g, () => `\\${${i++}:0}`)\n\t\t.replace(/\\(true\\|false\\)/g, () => `\\${${i++}:false}`)\n\t\t.replace(/\\.\\*/g, () => `\\${${i++}:TEXT}`)\n\t\t.replace(/\\\\/g, '');\n}\n\n// Replace snippet syntax with default value\nfunction replaceSnippetDefaults(str: string): string {\n\treturn str.replace(/\\$\\{\\d+:([^}]+)\\}/g, '$1');\n}\n\nexport function defaultComplInfo(): TS.CompletionInfo {\n\treturn {\n\t\tisGlobalCompletion: false,\n\t\tisMemberCompletion: false,\n\t\tisNewIdentifierLocation: false,\n\t\tentries: [],\n\t};\n}\n\nfunction getNodeTextSpan(node: TS.Node): TS.TextSpan {\n\tconst start = node.getStart() + 1;\n\treturn {\n\t\tstart,\n\t\tlength: node.getWidth() - 2,\n\t};\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { addExtraQuickInfo } from './docs';\nimport { TypeInfoFactory } from './info';\nimport { addTemplateCompletions, defaultComplInfo } from './completion';\n\nexport class UnionTypeDocsPlugin {\n\tprivate logger!: TS.server.Logger;\n\tprivate ls!: TS.LanguageService;\n\tprivate proxy!: TS.LanguageService;\n\tprivate typeInfoFactory!: TypeInfoFactory;\n\n\tconstructor(private readonly ts: typeof TS) {}\n\n\tcreate(info: TS.server.PluginCreateInfo) {\n\t\tthis.logger = info.project.projectService.logger;\n\t\tthis.ls = info.languageService;\n\t\tthis.typeInfoFactory = new TypeInfoFactory(this.ts, this.ls)!;\n\t\tthis.proxy = createLsProxy(this.ls);\n\t\tthis.proxy.getQuickInfoAtPosition = this.getQuickInfoAtPosition.bind(this);\n\t\tthis.proxy.getCompletionsAtPosition =\n\t\t\tthis.getCompletionsAtPosition.bind(this);\n\t\tthis.logger.info('[Union type docs plugin] Loaded');\n\t\treturn this.proxy;\n\t}\n\n\tprivate getQuickInfoAtPosition(fileName: string, pos: number) {\n\t\tconst quickInfo = this.ls.getQuickInfoAtPosition(fileName, pos);\n\t\tif (!quickInfo) return quickInfo;\n\t\ttry {\n\t\t\tconst typeInfo = this.typeInfoFactory.getTypeInfo(fileName, pos);\n\t\t\tif (!typeInfo) return quickInfo;\n\t\t\taddExtraQuickInfo(this.ts, quickInfo, typeInfo);\n\t\t} catch (err) {\n\t\t\tthis.logErr('Quick Info', err);\n\t\t}\n\n\t\treturn quickInfo;\n\t}\n\n\tprivate getCompletionsAtPosition(\n\t\tfileName: string,\n\t\tpos: number,\n\t\topts: TS.GetCompletionsAtPositionOptions | undefined,\n\t\tfmt?: TS.FormatCodeSettings\n\t): TS.WithMetadata<TS.CompletionInfo> | undefined {\n\t\tconst cmpl =\n\t\t\tthis.ls.getCompletionsAtPosition(fileName, pos, opts, fmt) ??\n\t\t\tdefaultComplInfo();\n\t\ttry {\n\t\t\tconst typeInfo = this.typeInfoFactory.getContextualTypeInfo(\n\t\t\t\tfileName,\n\t\t\t\tpos\n\t\t\t);\n\t\t\tif (!typeInfo) return cmpl;\n\t\t\taddTemplateCompletions(this.ts, cmpl, typeInfo);\n\t\t} catch (err) {\n\t\t\tthis.logErr('Completion', err);\n\t\t}\n\t\treturn cmpl;\n\t}\n\n\tprivate logErr(at: string, err: unknown) {\n\t\tthis.logger.msg(\n\t\t\t`[TS Union Docs ${at} Error]: ${errToString(err)}`,\n\t\t\tthis.ts.server.Msg.Err\n\t\t);\n\t}\n}\n\n// Create new object with all functions of the old language service\nfunction createLsProxy(oldLs: TS.LanguageService): TS.LanguageService {\n\tconst proxy = Object.create(null) as TS.LanguageService;\n\tfor (const k of Object.keys(oldLs) as Array<keyof TS.LanguageService>) {\n\t\tconst x = oldLs[k];\n\t\t(proxy as any)[k] = typeof x === 'function' ? x.bind(oldLs) : x;\n\t}\n\treturn proxy;\n}\n\nfunction errToString(err: unknown): string {\n\tif (err instanceof Error) return `${err.message} | ${err.stack}`;\n\telse if (typeof err === 'string') return err;\n\telse return String(err);\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { UnionTypeDocsPlugin } from './plugin';\n\nexport = (mod: { typescript: typeof TS }) =>\n\tnew UnionTypeDocsPlugin(mod.typescript);\n"],"names":["SupportedType"],"mappings":"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"}